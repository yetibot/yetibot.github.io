<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Yetibot: Dev Guide</title>
    <link rel="canonical" href="https://yetibot.com/dev-guide">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="/css/main.css" rel="stylesheet" type="text/css" />
    <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/img/favicon/site.webmanifest">
    <link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="/img/favicon/favicon.ico">

    
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://yetibot.com/dev-guide" />
    <meta property="og:title" content="Yetibot: Dev Guide" />
    <meta property="og:description"
      content="Yeitbot is a powerful, expressive chatops platform written in Clojure." />
    <meta property="og:image"
      content="https://yetibot.com/img/yetibot_logo.svg"
    />
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:domain" value="yetibot.com" />
    <meta name="twitter:title" value="Yetibot: Dev Guide" />
    <meta name="twitter:description"
      value="Yeitbot is a powerful, expressive chatops platform written in Clojure."
    />
    <meta name="twitter:image"
      content="https://yetibot.com/img/yetibot_logo.svg"
    />
    <meta name="twitter:url" value="https://yetibot.com/dev-guide" />
    
    

    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="msapplication-config" content="/img/favicon/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117101667-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117101667-1');
    </script>
  </head>
  <body class="">


    <div class="main-content">
      <nav class="navbar is-black" role="navigation" aria-label="main navigation">
        <div class="container">
          <div class="navbar-brand">
            <a class="navbar-item" href="/">
              <img class="nav-logo" src="/img/yetibot_lambda_blue_with_grey.svg"
                                    alt="Yetibot: A powerful, expressive chatops platform written in Clojure."
                                    />
            </a>

            <div class="navbar-burger" data-target="nav-menu">
              <span></span>
              <span></span>
              <span></span>
            </div>

          </div>
          <div class="navbar-menu" id="nav-menu">
            <div class="navbar-start">

              
              <a href="/user-guide"
                class="navbar-item is-tab
                ">
                User Guide
              </a>
              
              <a href="/dev-guide"
                class="navbar-item is-tab
                is-active">
                Dev Guide
              </a>
              
              <a href="/ops-guide"
                class="navbar-item is-tab
                ">
                Ops Guide
              </a>
              
              <a href="/community"
                class="navbar-item is-tab
                ">
                Community
              </a>
              
              <a href="/media"
                class="navbar-item is-tab
                ">
                Media
              </a>
              

              <a class="navbar-item is-tab
                " href="/archives">
                Blog
              </a>
            </div>
            <div class="navbar-end">

              <a href="https://twitter.com/yetibot_chatops"
                 title="Yetibot on Twitter"
                 class="navbar-item">
                <span class="icon">
                  <i class="fab fa-twitter"></i>
                </span>
              </a>
              <a href="https://github.com/yetibot/yetibot"
                 title="Yetibot on GitHub"
                 class="navbar-item">
                <span class="icon">
                  <i class="fab fa-github"></i>
                </span>
              </a>
              <a class="navbar-item"
                 title="Yetibot Slack"
                 href="https://slack.yetibot.com">
                <span class="icon">
                  <i class="fab fa-slack"></i>
                </span>
              </a>

            </div>
          </div>
        </div>
      </nav>

      

<article class="page-title hero is-light is-bold is-fullwidth">
  <div class="hero-body">
    <div class="container">
      <h1 class="title">Dev Guide</h1>
      <p class="subtitle">Yetibot internals and dev workflows</p>
    </div>
  </div>
</article>

<section class="section content">

  <div class="container">
    <div id="page">
      <div class="main columns">
        <div class="column main-content is-two-thirds">
          <p><!&ndash; can't indent this properly because Markdown turns it into a code block &ndash;> <article class="message is-info"> <div class="message-header">   <p>Tip</p> </div> <div class="message-body">   This guide is all about developing Yetibot. It includes docs about dev   workflow and Yetibot internals.</p><ul><li>If you're more interested in using Yetibot, check out the  <a href='/user-guide'>User Guide</a>.</li><li>If you're interested in running and operating your own instance of Yetibot,  check out the <a href='/ops-guide'>Operations Guide</a>.</div></article></li></ul><p><article class="message is-info"> <div class="message-header">   <p>Getting help</p> </div> <div class="message-body">   Although we hope the docs are useful and comprehensive,   <strong>don't hesitate to ask for help in <a href='https://slack.yetibot.com'>Slack</a>!</strong>   It could potentially save you a lot of time. </div> </article></p><p><article class="message is-warning"> <div class="message-header">   <p>üößüèóüë∑</p> </div> <div class="message-body"> These docs are work in progress. </div> </article></p><h2 id="dev&#95;workflow">Dev workflow</h2><h3 id="prerequisites">Prerequisites</h3><h4 id="leiningen">Leiningen</h4><p>Leiningen is the Clojure build tool that Yetibot uses. See the <a href='https://github.com/technomancy/leiningen#installation'>Leiningen Installation docs</a> to install it.</p><h4 id="postgres">Postgres</h4><p>Yetibot needs a Postgres database. It defaults to <code>yetibot</code> as the database name (this is configurable). Ensure you have Postgres installed, then create the database:</p><pre><code class="bash">createdb yetibot
</code></pre><p>The default connection string of <code>postgresql://localhost:5432/yetibot</code> should "just work".</p><h4 id="configuration">Configuration</h4><p>Make sure you've configured at least one chat adapter. This could be IRC or Slack. See <a href='https://yetibot.com/ops-guide#minimal_config'>Up and running / minimal config</a> docs for a simple IRC example.</p><p>For the full set of configuration options see the <a href='/ops-guide#configuration'>Ops Guide / Configuration section</a>.</p><h3 id="repl">REPL</h3><p>Start up a development REPL with:</p><pre><code class="bash">lein repl
</code></pre><p>Then run:</p><pre><code class="clojure">&#40;start&#41;
</code></pre><p>To load a core set of commands and connect to any configured adapters.</p><p>At this point a typical dev workflow would be to iteratively write and reload code from your editor as is common in the Clojure community. See <a href='http://clojure-doc.org/articles/content.html#essentials'>Essentials</a> for docs on setting up various editors for Clojure development.</p><p>You can also optionally load all commands from the REPL using:</p><pre><code class="clojure">&#40;load-all&#41;
</code></pre><p>To fully reload and restart the adapters and database connections, use:</p><pre><code class="clojure">&#40;reset&#41;
</code></pre><p>And to stop, use:</p><pre><code class="clojure">&#40;stop&#41;
</code></pre><p>See source for <a href='https://github.com/yetibot/yetibot.core/blob/master/src/yetibot/core/repl.clj'><code>yetibot.core.repl</code></a> for more info.</p><h3 id="linting">Linting</h3><p>Run this from the repo root to lint:</p><pre><code class="bash">codeclimate analyze
</code></pre><h2 id="building&#95;your&#95;first&#95;command">Building your first command</h2><p><article class="message is-info"> <div class="message-header">   <p>Heads up</p> </div> <div class="message-body">   If you're new to Yetibot usage, it might be useful to check out the   <a href='https://yetibot.com/blog/2019-03-26-yetibot-workshop-at-ebay'>Contributing to Yetibot screencast</a>   where we break down a non-trivial nested alias and explain how command   composition works. This screencast also includes livecoding a new feature   (adding <code>forecast</code> support to weather). </div> </article></p><p>Building a Yetibot command is easy. The primary interface is <code>cmd-hook</code>, which registers a command with its prefix and set of sub-commands.</p><p>Here's an example command that adds 2 numbers:</p><pre><code class="clojure">&#40;ns mycompany.plugins.commands.add
  &#40;:require &#91;yetibot.core.hooks :refer &#91;cmd-hook&#93;&#93;&#41;&#41;

&#40;defn add-cmd
  &quot;add &lt;number1&gt; &lt;number2&gt; # Add two numbers&quot;
  &#91;{&#91;&#95; n1 n2&#93; :match}&#93; &#40;+ &#40;read-string n1&#41; &#40;read-string n2&#41;&#41;&#41;

&#40;cmd-hook #&quot;add&quot; ;; command prefix
  ;; Pattern to match the subcommand on the left and the function to handle it
  ;; on the right. Notice that we specified a docstring on `add-cmd` - Yetibot
  ;; will use this to populate the help docs for the `add` command.
  #&quot;&#40;\d+&#41;\s+&#40;\d+&#41;&quot; add-cmd&#41;
</code></pre><p>An example invocation would look like:</p><pre><code>!add 2 3
5
</code></pre><p>And if we ask for help:</p><pre><code>!help add
add &lt;number1&gt; &lt;number2&gt; # Add two numbers
</code></pre><p>In addition to loading its own internal commands, Yetibot will load all command namespaces matching:</p><pre><code class="clojure">#&quot;&#94;.&#42;plugins\.commands.&#42;&quot;
</code></pre><p>So in our example above, the <code>mycompany.plugins.commands.add</code> namespace would be matched by this pattern and loaded.</p><p>For many more examples of various commands, take a look at <a href='https://github.com/yetibot/yetibot/tree/master/src/yetibot/commands'>Yetibot's built in commands</a>.</p><h2 id="testing&#95;yetibot.core&#95;changes&#95;in&#95;yetibot">Testing yetibot.core changes in yetibot</h2><p>If you need to test out changes to <code>yetibot.core</code> in <code>yetibot</code>, this can be done by installing the <code>yetibot.core</code> SNAPSHOT locally and consuming it from <code>yetibot</code>:</p><pre><code class="bash">&#91;yetibot.core&#93; $ lein install
Warning: specified :main without including it in :aot.
Implicit AOT of :main will be removed in Leiningen 3.0.0.
If you only need AOT for your uberjar, consider adding :aot :all into your
:uberjar profile instead.
Compiling yetibot.core.init
Created /Users/thartman/oss/yetibot.core/target/yetibot.core-x.y.z-SNAPSHOT.jar
Wrote /Users/thartman/oss/yetibot.core/pom.xml
Installed jar and pom into local repo.
</code></pre><p>Now in <code>yetibot</code>'s <code>project.clj</code>, set the dependency of <code>yetibot.core</code> to:</p><pre><code class="bash">&#91;yetibot.core &quot;x.y.z-SNAPSHOT&quot;&#93;
</code></pre><p>Of course you need to replace <code>x.y.z</code> with the actual version you're working on.</p><p>Make sure to never commit these kind of changes to <code>master</code> (assuming they somehow passed code review). Snapshot versions should only be used during development.</p><h2 id="command&#95;arguments">Command arguments</h2><p>Every command takes a single map argument containing things like the arguments to the command, chat source that the command originated from, any data that was propagated across a pipe, the Yetibot user, and the user who executed the command. Yetibot can show you these at runtime using <code>raw all</code>:</p><p>A simple command doesn't contain as much as a piped expression might:</p><pre><code class="yetibot">!echo hi | raw all
</code></pre><p>Note: <code>:yetibot-user</code> is unbound in this context because the GraphQL <code>chat-source</code> has no concept of a Yetibot user and is not a normal Adapter. Normally the Adapter would bind this. For example, in Slack <code>:yetibot-user</code> would be the entity that represents Yetibot's bot account in that Slack instance and in IRC it would be a simpler map representing the Yetibot user in IRC.</p><p>Let's peek at a slightly more complex example:</p><pre><code class="yetibot">!history | random | raw all
</code></pre><p>Here we can see more interesting data behind the pipe in addition to the standard keys:</p><ul><li><code>:cmd</code> - the top level command that was matched</li><li><code>:match</code> - this is the matched args in the subexpression - in this case  <code>&quot;all&quot;</code>.</li><li><code>:args</code> - this is the entire string passed to the command.</li><li><code>:data</code> - shows us the data behind the pipe, which in the case of a random  history item is the database entity.</li><li><code>:settings</code> - settings for the channel we're in. This is used for example to  disable categories, enable "broadcast" (i.e. allow Tweets from the stream to  be posted into the channel as they arrive) or set the <code>jira-project</code> which is  used to specify the default project(s) in the <code>jira</code> command.</li></ul><p>Any of these can be used by your command to do interesting things. Some commands care about which user executed them (e.g. <code>karma</code>). Other commands pay attention to the channel-specific settings (e.g. <code>jira</code>).</p><h2 id="command&#95;response&#95;structure">Command response structure</h2><p>The result of a command can be a simple value e.g. a string or collection of strings. These will be passed directly to the chat adapter to be posted either as a single message (like the case of a String) or as multiple messages or a single multi-line message for collections, depending on the capabilities of the chat adapter. For example, <code>echo</code>:</p><pre><code class="clojure">&#40;defn echo-cmd
  &quot;echo &lt;text&gt; # Echos back &lt;text&gt;. Useful for piping.&quot;
  {:yb/cat #{:util}}
  &#91;{:keys &#91;args&#93;}&#93;
  args&#41;

&#40;cmd-hook #&quot;echo&quot;
  &#95; echo-cmd&#41;
</code></pre><p>This command simply returns its string args. This was the original behavior of all commands, but much later we devised a more precise structure that allows Yetibot to:</p><ol><li>pass data across pipes and</li><li>explicitly indicate when an error has occurred.</li></ol><p>In the first case (i.e. non error results), a command can return:</p><pre><code class="clojure">{:result/value &quot;The formatted string derived from some data&quot;
 :result/data {:the {:data :structure}}}
</code></pre><p>In the second case (i.e. errors), a command should return a <code>:result/error</code> key with an error message string value to indicate that an error took place. This allows Yetibot to short-circuit pipe expressions early in the face of errors, making it more clear what happened in an expression:</p><pre><code class="clojure">{:result/error &quot;The API blew up&quot;}
</code></pre><p>Let's look at these in more detail.</p><h3 id="data&#95;across&#95;pipes">Data across pipes</h3><p>Many commands resolve some sort of data structure through an API call then pull attributes out of a structure and format them into a human-friendly string. This is often great from a UX perspective, but we give up so much data in the process of deriving that string. What if we could have the best of both worlds?</p><p>To illustrate the point let's look at a <code>weather</code> command:</p><pre><code class="yetibot">!weather seattle, wa
</code></pre><p>This is a nice human-friendly representation of the current weather conditions for Seattle, but how much data are we losing in the process of deriving that string? Let's peak at the actual data:</p><pre><code class="yetibot">!weather seattle, wa | data show
</code></pre><p>That's a lot of data! Since Yetibot passes this data across pipes, we can craft commands that utilize it in some way. One of Yetibot's built-in commands, <code>render</code>, does exactly that. It allows a user to provide their own formatting with string templates.</p><pre><code class="yetibot">!help render
</code></pre><p>To demonstrate how a user could harness all this data to come up with their own human-readable derivation (this is the same example taken from the <a href='/user-guide#render'>user docs</a>):</p><pre><code class="yetibot">!weather seattle | render Wind in {{city&#95;name}} at {{wind&#95;spd|multiply:2.23694|double-format:2}} mph blowing {{wind&#95;cdir&#95;full|capitalize}}
</code></pre><p>Check out the source for the <code>weather</code> command to see how it works:</p><pre><code class="yetibot">!source yetibot.commands.weather/weather-cmd
</code></pre><p>It's not a requirement that your command outputs this structure, but it's highly recommended!</p><h4 id="symmetry&#95;between&#95;<code>:result/data</code>&#95;and&#95;<code>:result/value</code>">Symmetry between <code>:result/data</code> and <code>:result/value</code></h4><p>Returning <code>:result/data</code> from commands is great, but we need to be intentional about the symmetry between data and the human-friendly derived representation (i.e. <code>:result/value</code>). If we maintain symmetry, then collection commands such as <code>random</code> or <code>head</code> or <code>tail</code> can continue to propagate the data.</p><p>As an example, let's look at the response from <code>github search</code>:</p><pre><code class="yetibot">!github search cmd-hook org:yetibot
</code></pre><p>This command makes an API call via GitHub's API which gives us a response like:</p><pre><code class="clojure">{:total&#95;count 104,
 :incomplete&#95;results false,
 :items
 &#91;{:name &quot;codeclimate.clj&quot;,
   :path &quot;src/yetibot&#95;codeclimate/plugins/commands/codeclimate.clj&quot;,
   :sha &quot;9e13c91b2c40abe538b98e5c74f320aaa620aefd&quot;,
   :url
   &quot;https://api.github.com/repositories/50538984/contents/src/yetibot&#95;codeclimate/plugins/commands/codeclimate.clj?ref=46a59493ff7d249dcc9d33b479f41be623ec65a8&quot;,
   :git&#95;url
   &quot;https://api.github.com/repositories/50538984/git/blobs/9e13c91b2c40abe538b98e5c74f320aaa620aefd&quot;,
   :html&#95;url
   &quot;https://github.com/yetibot/yetibot-codeclimate/blob/46a59493ff7d249dcc9d33b479f41be623ec65a8/src/yetibot&#95;codeclimate/plugins/commands/codeclimate.clj&quot;,
   :repository
   {:html&#95;url &quot;https://github.com/yetibot/yetibot-codeclimate&quot;,
    :description &quot;:rocket: Yetibot plugin for CodeClimate integration&quot;,
    ;; ... elided
    },
   :score 33.93865}
  {:name &quot;stackstorm.clj&quot;,
   :path &quot;src/yetibot&#95;stackstorm/plugins/commands/stackstorm.clj&quot;,
   :sha &quot;0bb9fec80a83b51d1dbbc7828d9745934856228d&quot;,
   :url
   &quot;https://api.github.com/repositories/45482966/contents/src/yetibot&#95;stackstorm/plugins/commands/stackstorm.clj?ref=d5a26ceecba749ecedd2df2c8dc2984df7d46c32&quot;,
   :git&#95;url
   &quot;https://api.github.com/repositories/45482966/git/blobs/0bb9fec80a83b51d1dbbc7828d9745934856228d&quot;,
   :html&#95;url
   &quot;https://github.com/yetibot/yetibot-stackstorm/blob/d5a26ceecba749ecedd2df2c8dc2984df7d46c32/src/yetibot&#95;stackstorm/plugins/commands/stackstorm.clj&quot;,
   :repository {} ;; elided
   :score 31.011341}
</code></pre><p>But the human friendly <code>:result/value</code> looks like:</p><pre><code>https://github.com/yetibot/yetibot-codeclimate/blob/46a59493ff7d249dcc9d33b479f41be623ec65a8/src/yetibot&#95;codeclimate/plugins/commands/codeclimate.clj
https://github.com/yetibot/yetibot-stackstorm/blob/d5a26ceecba749ecedd2df2c8dc2984df7d46c32/src/yetibot&#95;stackstorm/plugins/commands/stackstorm.clj
</code></pre><p>listing only the <code>:html&#95;url</code> of each item in the <code>:items</code> vector.</p><p>In order for collection commands to propagate data, we need symmetry between the collection of values in <code>:result/value</code> and the data structure in <code>:result/data</code>, meaning each item in <code>:result/value</code> has a corresponding data item in <code>:result/data</code>. One way to do this would be to return the <code>:items</code> collection as <code>:result/data</code> but we'd be giving up useful data in the process (<code>:total&#95;count</code> for example).</p><p>Instead, we can attach a hint to the result map using the <code>:result/collection-path</code> key specifying the path to the items collection that was used to derive a human-friendly representation:</p><pre><code class="clojure">&#40;let &#91;{items :items :as result} &#40;gh/search-code query&#41;&#93;
  {:result/data result
   :result/collection-path &#91;:items&#93;
   :result/value &#40;map :html&#95;url items&#41;}&#41;
</code></pre><p>The expression pipeline will see this and use <code>get-in</code> on the value of <code>:result/data</code> to obtain the subset of data and pass it to command handlers under the <code>:data-collection</code> key.</p><p>Collection utilities use <code>data-collection</code> to propagate the correct data that mirrors the transformation it applies to <code>opts</code>. For example, here is how <code>random</code> propagates the proper data:</p><pre><code class="clojure">&#40;defn random
  &quot;random &lt;list&gt; # returns a random item from &lt;list&gt;
   random # generate a random number&quot;
  {:yb/cat #{:util :collection}}
  &#91;{:keys &#91;data-collection&#93; items :opts}&#93;
  &#40;if &#40;not &#40;empty? items&#41;&#41;
    &#40;let &#91;idx &#40;rand-int &#40;count &#40;ensure-items-collection items&#41;&#41;&#41;
          item &#40;nth items idx&#41;
          data &#40;when data-collection &#40;nth data-collection idx&#41;&#41;&#93;
     {:result/value item
      :result/data data}&#41;
    &#40;str &#40;rand 100000&#41;&#41;&#41;&#41;
</code></pre><ol><li>Generate a random int within the range of <code>items</code> length</li><li>Extract the nth item from <code>items</code></li><li>Extract the corresponding nth item from <code>data-collection</code></li><li>Return these together as <code>:result/value</code> and <code>:result/data</code></li></ol><h3 id="errors">Errors</h3><p>Along the same lines as <code>:result/data</code> demonstrated in the previous section, a command can explicitly return an error by returning a <code>{:result/error &quot;error message&quot;}</code> map. The <code>weather</code> command uses this structure to indicate an invalid location:</p><pre><code class="yetibot">!weather bad location
</code></pre><pre><code class="yetibot">!source yetibot.commands.weather/error-response
</code></pre><h2 id="command&#95;handling&#95;pipeline">Command handling pipeline</h2><p>This describes an overview of how yetibot takes raw input and passes it through its command handling pipeline.</p><h3 id="raw&#95;input">Raw input</h3><p><code>yetibot.core.handler/handle-raw</code> is passed params from an adapter:</p><ul><li><code>chat-source</code> e.g. <code>{:adapter :irc :room &quot;#clojure&quot;}</code></li><li><code>user</code> e.g. <code>{:name devth, :username devth, :id &#126;devth, :user &#126;devth, :nick devth}</code></li><li><code>event-type</code> one of: <code>:message</code>, <code>:react</code>, <code>:leave</code>, <code>:enter</code>, <code>:sound</code>, <code>:kick</code></li><li><code>body</code> this is the actual text the user wrote. Only <code>event-type</code>s of  <code>:message</code> and <code>:react</code> have a <code>body</code>. Otherwise it is <code>nil</code>. When not <code>nil</code>,  <code>handle-raw</code> checks to see if the <code>body</code> is prefixed with <code>!</code>. If it is,  <code>handle-raw</code> strips the leading <code>!</code> and  <code>yetibot.core.handler/handle-unparsed-expr</code> is called with <code>chat-source</code>,  <code>user</code>, and <code>body</code>.</li></ul><h3 id="unparsed&#95;expression&#95;handling">Unparsed expression handling</h3><p>Raw, unparsed expression are passed to <code>yetibot.core.handler/handle-unparsed-expr</code>, along with the <code>user</code> and <code>body</code>. <code>handle-unparsed-expr</code> sets a <code>binding</code> for the latter 2, then parses and evaluates the expression using <code>yetibot.core.parser/parse-and-eval</code>.</p><h3 id="parsing">Parsing</h3><p><code>yetibot.core.parser</code> is an <a href='https://github.com/Engelberg/instaparse'>Instaparse</a> parser, which fully specifies the yetibot grammar, including arbitrarily-nested subexpressions, piped commands and literals. Once a raw expression is parsed into an AST, it is evaluated using Instaparse's <code>transform</code> helper, which takes a map of AST keys to functions. The important function here is <code>yetibot.core.interpreter/handle-expr</code> which takes any number of individual commands to be reduced using pipe semantics.</p><h3 id="evaluating">Evaluating</h3><p><code>handle-expr</code> literally <code>reduce</code>s its <code>cmds</code> arguments over the <code>yetibot.core.interpreter/pipe-cmds</code>. Each command is evaluated from left to right, and each evaluation output is passed as arguments to the next command. Command output can either be a single value, or a collection of values. This affects the method <code>pipe-cmds</code> will pass it to the next comand:</p><ul><li><strong>Single value</strong>: <code>pipe-cmds</code> will simply append it using  <code>yetibot.core.util/pseudo-format</code>, which is similar to <code>clojure.core/format</code>  except it will append the value at the end of the string if there is not a  <code>%s</code> placeholder present, and if there are <em>multiple</em> <code>%s</code>s present, it will  replace <em>all</em> of them with the value.</li><li><strong>Collection</strong>: <code>pipe-cmds</code> passes the collection as an optional <code>:opts</code> key  in the <code>extra</code> argument to <code>yetibot.core.interpreter/handle-cmd</code>, letting  individual commands do whatever they like with the <code>:opts</code>. For example, many  of the <code>yetibot.core.commands.collections</code> commands require a <code>:opts</code> key as  they primarily operate on collections.</li></ul><p><code>yetibot.core.interpreter/handle-cmd</code> is the function that gets <a href='https://github.com/technomancy/robert-hooke/'>hooked</a> by <code>yetibot.core.hooks</code>. Each command in the <code>yetibot.core.interpreter/hooks</code> collection gets to look at the args and decide whether it can handle the input or not. As soon as a single command handles it, evaluation is complete. If no command handles it, <code>handle-cmd</code> will fallback on google image search.</p><h3 id="command&#95;arguments">Command arguments</h3><p>Use <code>raw all</code> to view all arguments.</p><pre><code class="yetibot">!range 3 | raw all
</code></pre><h4 id="data">Data</h4><h3 id="push&#95;down&#95;operations">Push down operations</h3><p>Yetibot has the ability to look ahead into the command pipeline and optionally consume subsequent commands from a command handler function. In relational algebra this is often referred to as pushing down an operation.</p><p>Consider <code>history | random</code> as an example. The <code>history</code> command looks ahead at the next commands in the pipeline, sees that it's a command it knows how to consume (<code>random</code>), and tells the command execution pipeline to skip it for efficiency and instead handle itself.</p><p>Imagine the default naive method Yetibot would execute if this were not the case:</p><ol><li>Load all history into a data structure</li><li>Pass the data structure to <code>random</code> which calls <code>rand-nth</code> on the collection.   According to the <a href='https://public.yetibot.com/'>public Yetibot dashboard</a> at   the time of writing we have 12,723 entries in the history table. This isn't   that much but you can imagine how slow it'd be as the table continues to   grow.</li></ol><p>The full set of commands that <code>history</code> consumes are defined in <a href='https://github.com/yetibot/yetibot.core/blob/f2e045002e20adccb79adbb84eb12566fc99c51e/src/yetibot/core/commands/history.clj#L8'><code>yetibot.core.commands.history/consumeables</code></a>:</p><pre><code class="clojure">&#40;def consumables #{&quot;head&quot; &quot;tail&quot; &quot;count&quot; &quot;grep&quot; &quot;random&quot;}&#41;
</code></pre><p>See <a href='https://github.com/yetibot/yetibot.core/blob/master/src/yetibot/core/commands/history.clj#L46-L61'>the history command</a> for a full example.</p><h3 id="timeouts">Timeouts</h3><h3 id="testing&#95;commands">Testing commands</h3><ol><li>Using <code>command-execution-info</code></li><li>Mocking with Midje</li></ol><h2 id="parsing&#95;command&#95;options">Parsing command options</h2><p>A Yetibot command can parse options, much like you would encounter using common CLI tools. This is made possible by using the <code>clojure.tools.cli</code> library and related <code>parse-opts</code> function.</p><p>Here's an example command that would parse a <code>name</code> option:</p><pre><code class="clojure">&#40;ns mycompany.plugins.commands.hello
  &#40;:require &#91;yetibot.core.hooks :refer &#91;cmd-hook&#93;&#93;
            &#91;clojure.tools.cli :refer &#91;parse-opts&#93;&#93;
            &#91;clojure.string :refer &#91;split&#93;&#93;&#41;&#41;

&#40;def cli-options &#91;&#91;&quot;-n&quot; &quot;--name NAME&quot;&#93;&#93;&#41;

&#40;defn hello-cmd
  &quot;hello # say hello
   
   Personalize the hello:
   -n --name &lt;name&gt;&quot;
  &#91;{:keys &#91;match&#93;}&#93;
  &#40;let &#91;{options :options} &#40;parse-opts &#40;split match #&quot; &quot;&#41; cli-options&#41;&#93;
    &#40;if &#40;:name options&#41;
      ; enthusiastically say hello to the name
      &#40;str &quot;Hello &quot; &#40;:name options&#41; &quot;!&quot;&#41;
      ; otherwise just greet
      &quot;Greetings.&quot;&#41;&#41;&#41;

&#40;cmd-hook #&quot;hello&quot;
          &#95; hello-cmd&#41;
</code></pre><p>An example invocation would look like:</p><pre><code>!hello -n Bob
Hello Bob!

!hello
Greetings.
</code></pre><p>For a more elaborate example of using <code>parse-opts</code>, take a look at <a href='https://github.com/yetibot/yetibot.core/blob/master/src/yetibot/core/commands/history.clj'>Yetibot's history command</a>.</p><h2 id="working&#95;with&#95;the&#95;database">Working with the database</h2><h2 id="parser">Parser</h2><h2 id="load&#95;order">Load order</h2><p>Yetibot loads itself in a particular order. The database should be initialized and schemas loaded as soon as possible, since many models load themselves based on it. We want to start logging as soon as possible.</p><h3 id="database&#95;namespaces">Database namespaces</h3><p>All database schemas should live in <code>db</code> namespaces:</p><ul><li><code>yetibot.db.&#42;</code></li><li><code>yetibot.core.db.&#42;</code></li><li><code>&#42;.plugins.db.&#42;</code></li></ul><p>The <code>yetibot.core.db</code> namespace will map over these, building up their <code>schema</code>s if available.</p><h3 id="logging">Logging</h3><p><code>start</code> fn is called on <code>yetibot.core.logging</code> to initialize its database-appender.</p><h3 id="chat&#95;adapters">Chat adapters</h3><p>Chat adapters are loaded next. Their <code>start</code> functions are called, which connects to the chat protocol and bootstraps its users into the <code>users</code> model.</p><h3 id="observers&#95;and&#95;commands">Observers and commands</h3><p>Finally, observers and commands are loaded. These typically <code>require</code> models and api namespaces, which may make network or database calls to bootstrap data.</p><h2 id="graphql&#95;api">GraphQL API</h2><p>Yetibot hosts a GraphQL powered API. The public instance is available at <a href='https://public.yetibot.com/graphql'>https://public.yetibot.com/graphql</a>. Try hitting it with <code>curl</code>:</p><pre><code class="bash">curl 'https://public.yetibot.com/graphql' \
  -H 'Accept: application/json' \
  --data 'query=%7Beval&#40;expr%3A%20%22uptime%22&#41;%7D' \
  --compressed
</code></pre><h2 id="web&#95;dashboard">Web dashboard</h2><p>Yetibot hosts a web-based frontend powered by the GraphQL API. See the public instance at <a href='https://public.yetibot.com'>public.yetibot.com</a>.</p><h2 id="working&#95;with&#95;docker&#95;locally">Working with Docker locally</h2><p>Sometimes we need to make changes to the <code>Dockerfile</code> and test them locally.</p><p>Here's one way to do so without having to worry about running a Postgres instance or mess with config.</p><p>After making changes to <code>Dockerfile</code> in the root of the <a href='https://github.com/yetibot/yetibot'>main Yetibot repo</a>:</p><pre><code class="bash"># 1. build a new docker image
docker build -t yetibot/local .

# 2. optionally edit docker-compose.local.yml to adjust configuration

# 3. test out the new image using docker-compose.local.yml to override the image
# and any other config you'd like to modify:
docker-compose -f docker-compose.yml -f docker-compose.local.yml up
</code></pre><h2 id="configuration&#95;constraints">Configuration constraints</h2><p>Yetibot allows several configuration mechanisms in an attempt to afford the operator of a Yetibot the most convenient method according to their environment, tooling and preferences. To support this level of flexibility we must adopt two constraints:</p><ol><li>All config values are strings</li><li><code>&#95;</code> or <code>-</code> are not used in configuration key names as they represent levels   of nesting.</li></ol><p>For example: all of these are equivalent:</p><pre><code class="clojure">;; config.edn
{:yetibot
 {:aws
  {:access
   {:key &quot;lol&quot;}}}}
</code></pre><pre><code class="shell"># shell
export YETIBOT&#95;AWS&#95;ACCESS&#95;KEY=&quot;lol&quot;
</code></pre><pre><code class="clojure">;; profiles.clj &#40;leiningen&#41;
:yetibot-aws-access-key &quot;lol&quot;
</code></pre><p>In the future we will lint configuration to prevent violations of these constraints, such as when a developer only uses the <code>config.edn</code> mechanism, which is more expressive than the other two.</p><p>For more information, see:</p><ol><li><a href='https://yetibot.com/ops-guide#prefixes'>Ops Guide / Configuration / Prefixes</a></li><li><a href='https://devth.com/2018/dec-deep-environmental-config'>dec: Deep Environmental Config</a></li></ol><h2 id="testing&#95;philosophy">Testing philosophy</h2><p>Tests should allow for a typical REPL driven workflow, just like typical development. This means every <code>fact</code> should be idempotent and able to be exercised in isolation, apart from other facts in a given test namespace.</p><p>Database setup can occur but as an alternative, consider mocking out side effectual functions.</p><p>All new tests should use Midje. Some old tests remain that still need to be ported.</p><h2 id="ü§î">ü§î</h2><p><article class="message is-info"> <div class="message-header">   <p>Docs didn't answer your question?</p> </div> <div class="message-body">   Ask us in <a href='https://slack.yetibot.com'>Slack</a> or   <a href='https://github.com/yetibot/community/issues/new'>open a new issue</a>   on the <code>community</code> repo. </div> </article></p><p><span class="icon">   <i class="fab fa-github"></i> </span> <a href='https://github.com/yetibot/yetibot.github.io/blob/source/resources/templates/md/pages/dev-guide.md'>Edit this page</a></p>
        </div>

        <div class="column toc">
          <ol class="content"><li><a href="#dev_workflow">Dev workflow</a></li><ol><li><a href="#prerequisites">Prerequisites</a></li><ol><li><a href="#leiningen">Leiningen</a></li><li><a href="#postgres">Postgres</a></li><li><a href="#configuration">Configuration</a></li></ol><li><a href="#repl">REPL</a></li><li><a href="#linting">Linting</a></li></ol><li><a href="#building_your_first_command">Building your first command</a></li><li><a href="#testing_yetibot.core_changes_in_yetibot">Testing yetibot.core changes in yetibot</a></li><li><a href="#command_arguments">Command arguments</a></li><li><a href="#command_response_structure">Command response structure</a></li><ol><li><a href="#data_across_pipes">Data across pipes</a></li><ol><li><a href="#symmetry_between_&lt;code&gt;:result/data&lt;/code&gt;_and_&lt;code&gt;:result/value&lt;/code&gt;">Symmetry between <code>:result/data</code> and <code>:result/value</code></a></li></ol><li><a href="#errors">Errors</a></li></ol><li><a href="#command_handling_pipeline">Command handling pipeline</a></li><ol><li><a href="#raw_input">Raw input</a></li><li><a href="#unparsed_expression_handling">Unparsed expression handling</a></li><li><a href="#parsing">Parsing</a></li><li><a href="#evaluating">Evaluating</a></li><li><a href="#command_arguments">Command arguments</a></li><ol><li><a href="#data">Data</a></li></ol><li><a href="#push_down_operations">Push down operations</a></li><li><a href="#timeouts">Timeouts</a></li><li><a href="#testing_commands">Testing commands</a></li></ol><li><a href="#parsing_command_options">Parsing command options</a></li><li><a href="#working_with_the_database">Working with the database</a></li><li><a href="#parser">Parser</a></li><li><a href="#load_order">Load order</a></li><ol><li><a href="#database_namespaces">Database namespaces</a></li><li><a href="#logging">Logging</a></li><li><a href="#chat_adapters">Chat adapters</a></li><li><a href="#observers_and_commands">Observers and commands</a></li></ol><li><a href="#graphql_api">GraphQL API</a></li><li><a href="#web_dashboard">Web dashboard</a></li><li><a href="#working_with_docker_locally">Working with Docker locally</a></li><li><a href="#configuration_constraints">Configuration constraints</a></li><li><a href="#testing_philosophy">Testing philosophy</a></li><li><a href="#ü§î">ü§î</a></li></ol>
        </div>
      </div>

      <div id="prev-next">
        
        <a class="button is-warning" href="/user-guide">&laquo; User Guide</a>
        
        

        
        
        <a class="button is-warning"
          href="/ops-guide">Ops Guide ‚Ü†</a>
        
      </div>
    </div>
  </div>

</section>



    </div>

    <footer class="footer">
      <div class="content has-text-centered">
        <p>
          <strong>Yetibot</strong> by <a href="https://devth.com">Trevor
            Hartman</a> & <a href="/community#core_team">contributors</a>.
          <br />
          Distributed under the
          <a href="https://opensource.org/licenses/eclipse-1.0.php">
            Eclipse Public License 1.0</a>.
          <br />
          Artwork by
          <a href="http://www.freeformdesign.co/">Freeform Design Co.</a>
          in <strong>Montana</strong>.
          <br />

          This site is continously delivered from
          <a href="https://github.com/yetibot/yetibot.github.io">
             source</a>.
        </p>
        <a onClick="window.scroll({top: 0, left: 0, behavior: 'smooth'});
          history.replaceState({}, '', window.location.pathname);">
          <img class="logo" src="/img/yetibot_logo.svg" />
        </a>
      </div>
    </footer>

    <script src="/js/dist.js?q=010720205344" type="text/javascript" charset="utf-8"></script>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    <script src="/js/highlight.pack.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

